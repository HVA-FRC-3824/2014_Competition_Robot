// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc3824.CompetitionRobot.subsystems;
import org.usfirst.frc3824.CompetitionRobot.RobotMap;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import org.usfirst.frc3824.CompetitionRobot.Constants;
/**
 *
 */
public class AuxiliaryLeft extends Subsystem
{
    private boolean m_vacuumActive = false;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController shooterMotor = RobotMap.auxiliaryLeftShooterMotor;
    AnalogChannel shooterAngle = RobotMap.auxiliaryLeftShooterAngle;
    PIDController shooterAnglePID = RobotMap.auxiliaryLeftShooterAnglePID;
    DoubleSolenoid verticalAdjust = RobotMap.auxiliaryLeftVerticalAdjust;
    SpeedController vacuum = RobotMap.auxiliaryLeftVacuum;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand()
    {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
        // Vacuum is on/off only, set the direction to forward only, so ON is 
        //  equivalent to kForward
        vacuum.set(0.0);
        verticalAdjust.set(DoubleSolenoid.Value.kOff);
    }
    //====================================================================================
    // Deployment piston control methods
    //====================================================================================
    /**
     * <b><u>Deployment Piston Control Method</u></b>
     * <p>
     * Deploy Piston</p>
     */
    public void setVerticalDeploy()
    {
        verticalAdjust.set(DoubleSolenoid.Value.kForward);
    }
    /**
     * <b><u>Deployment Piston Control Method</u></b>
     * <p>
     * Retract Piston</p>
     */
    public void setVerticalRetract()
    {
        verticalAdjust.set(DoubleSolenoid.Value.kReverse);
    }
    /**
     * <b><u>Deployment Piston Control Method</u></b>
     * <p>
     * Stop Piston</p>
     */
    public void setVerticalStop()
    {
        verticalAdjust.set(DoubleSolenoid.Value.kOff);
    }
    //====================================================================================
    // Vacuum Control methods
    //====================================================================================
    /**
     * <b><u>Vacuum Control Method</u></b>
     * <p>
     * Turns the vacuum on.</p>
     */
    public void setVacuumOff()
    {
        vacuum.set(0.0);
        m_vacuumActive = false;
    }
    /**
     * <b><u>Vacuum Control Method</u></b>
     * <p>
     * Turns the vacuum off.</p>
     */
    public void setVacuumOn()
    {
        vacuum.set(1.0);
        m_vacuumActive = true;
    }
    /**
     * <b><u>Vacuum Control Method</u></b>
     * <p>
     * Toggles the state of the vacuum.</p>
     */
    public void vacuumToggle()
    {
        if (m_vacuumActive == true)
        {
            // if vacuum is on, turn it off!
            vacuum.set(0.0);
            m_vacuumActive = false;
        } else if (m_vacuumActive == false)
        {
            // if vacuum is off, turn it on!
            vacuum.set(1.0);
            m_vacuumActive = true;
        }
}
    //====================================================================================
    // Shooter Angle Control methods
    //====================================================================================
    /**
     * Sets the motor angle of the auxiliary arm.
     * <p>
     * Resets the PID Controller.
     * <br>Sets the setpoint to the angle value converted to ADC.</br>
     * <br>Enables the PID Controller.</br></p>
     *
     * @param adcVal - the angle to set
     */
    //------------------------------------------------------------------------------------
    public void setShooterAngle(double adcVal)
    {
        // Convert angle into 0-5V for the PID
        //shooterAnglePID.reset();
        shooterAnglePID.setSetpoint(adcVal);
        shooterAnglePID.enable();
    }
    public double getShooterSetpoint()
    {
        return shooterAnglePID.getSetpoint();
    }
    public void setShooterTestPID(double pid)
    {
        shooterAnglePID.setSetpoint(pid);
    }
    public void setShooterTestStartPID()
    {
        shooterAnglePID.enable();
    }
    public void setShooterStop()
    {
        // Disables the PID
        shooterAnglePID.disable();
    }
    public boolean getAtAngle()
    {
        return shooterAnglePID.onTarget();
    }
    //====================================================================================
    // Conversion methods
    //====================================================================================
    /**
     * Converts the input angle from degrees to an ADC value.
     *
     * @return converted ADC value
     */
    public double getMotorPower()
    {
        return shooterMotor.get();
    }
    /**
     * Converts the input ADC value to an angle in degrees.
     *
     * @param ADC - ADC value to convert to an angle in degrees
     * @return converted angle
     */
    private double convertADCtoAngle(double ADC)
    {
        double adcRatio;
        adcRatio = (ADC - Constants.AUX_MIN_ANGLE_ADCVAL) / (Constants.AUX_MAX_ANGLE_ADCVAL - Constants.AUX_MIN_ANGLE_ADCVAL);
        return (Constants.AUX_MAX_ANGLE - Constants.AUX_MIN_ANGLE) * (adcRatio) + Constants.AUX_MIN_ANGLE;
    }
    /**
     * Returns the angle of the auxiliary motor.
     *
     * @return angle of auxiliary motor
     */
    public double getAuxiliaryAngle()
    {
        return convertADCtoAngle(shooterAngle.pidGet());
    }
    /**
     * Returns the ADC of the auxiliary motor.
     *
     * @return ADC of auxiliary motor
     */
    public double getAuxiliaryPIDValue()
    {
        return shooterAngle.pidGet();
    }
}
