// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc3824.CompetitionRobot.subsystems;
import org.usfirst.frc3824.CompetitionRobot.RobotMap;
import org.usfirst.frc3824.CompetitionRobot.commands.*;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc3824.CompetitionRobot.Constants;
import org.usfirst.frc3824.CompetitionRobot.Robot;
/**
 *
 */
public class AuxiliaryLeft extends Subsystem
{
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Solenoid shootSolenoid1 = RobotMap.auxiliaryLeftShootSolenoid1;
    Solenoid shootSolenoid2 = RobotMap.auxiliaryLeftShootSolenoid2;
    Relay vacuum = RobotMap.auxiliaryLeftVacuum;
    SpeedController shooterMotor = RobotMap.auxiliaryLeftShooterMotor;
    AnalogChannel shooterAngle = RobotMap.auxiliaryLeftShooterAngle;
    PIDController shooterAnglePID = RobotMap.auxiliaryLeftShooterAnglePID;
    DoubleSolenoid verticalAdjust = RobotMap.auxiliaryLeftVerticalAdjust;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand()
    {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
        // Vacuum is on/off only, set the direction to forward only, so ON is 
        //  equivalent to kForward
        vacuum.setDirection(Relay.Direction.kForward);
        verticalAdjust.set(DoubleSolenoid.Value.kOff);
    }
    
    //------------------------------------------------------------------------------------
    // Deployment piston control methods
    //------------------------------------------------------------------------------------
    public void setVerticalDeploy()
    {
        verticalAdjust.set(DoubleSolenoid.Value.kForward);
    }
    
    public void setVerticalRetract()
    {
        verticalAdjust.set(DoubleSolenoid.Value.kReverse);
    }
    
    //------------------------------------------------------------------------------------
    // Shooter piston control methods
    //------------------------------------------------------------------------------------
    public void setShooterDeploy()
    {
        shootSolenoid1.set(true);
        shootSolenoid2.set(true);
    }
    
    public void setShooterRetract()
    {
        shootSolenoid1.set(false);
        shootSolenoid2.set(false);
    }
    
    //------------------------------------------------------------------------------------
    // Vacuum Control methods
    //------------------------------------------------------------------------------------
    public void setVacuumOff()
    {
        vacuum.set(Relay.Value.kOff);
    }
    
    public void setVacuumOn()
    {
        vacuum.set(Relay.Value.kOn);
    }
    
    public void setVacuumToggle()
    {
        if (Relay.Value.kOn == vacuum.get())
        {
            vacuum.set(Relay.Value.kOff);
        }
        else
        {
            vacuum.set(Relay.Value.kOn);
        }
    }
    
    //------------------------------------------------------------------------------------
    // Shooter Angle Control methods
    //------------------------------------------------------------------------------------
    public void setShooterAngle(double angle)
    { 
        // Convert angle into 0-5V for the PID
        shooterAnglePID.reset();
        shooterAnglePID.setSetpoint(convertAngleToADC(angle));
        shooterAnglePID.enable();
    }
    
    public void setShooterTestPID(double pid)
    { 
        shooterAnglePID.setSetpoint(pid);
    }
    
    public void setShooterTestStartPID()
    {
        shooterAnglePID.enable();
    }
    
    public void setShooterStop()
    {
        // Disables the PID
        shooterAnglePID.disable();
    }
    
    public boolean getAtAngle()
    {
        return shooterAnglePID.onTarget();
    }
    
    //------------------------------------------------------------------------------------
    // Conversion methods
    //------------------------------------------------------------------------------------
    private double convertAngleToADC(double angle)
    {
       double angleRatio;
       
       angleRatio = ((angle - Constants.AUX_MIN_ANGLE) / (Constants.AUX_MAX_ANGLE - Constants.AUX_MIN_ANGLE));
       return (Constants.AUX_MAX_ANGLE_ADCVAL - Constants.AUX_MIN_ANGLE_ADCVAL) * angleRatio + Constants.AUX_MIN_ANGLE_ADCVAL;
    }
    
    private double convertADCtoAngle(double ADC)
    {
       double adcRatio;
       
       adcRatio = (ADC - Constants.AUX_MIN_ANGLE_ADCVAL) / (Constants.AUX_MAX_ANGLE_ADCVAL - Constants.AUX_MIN_ANGLE_ADCVAL);
       return (Constants.AUX_MAX_ANGLE - Constants.AUX_MIN_ANGLE) * (adcRatio) + Constants.AUX_MIN_ANGLE;
    }
    
    public double getAuxiliaryAngle()
    {
        return convertADCtoAngle(shooterAngle.pidGet());
    }
    
    public double getAuxiliaryPIDValue()
    {
        return shooterAngle.pidGet();
    }
}
