// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc3824.CompetitionRobot.commands;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.DriverStationEnhancedIO;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc3824.CompetitionRobot.Constants;
import org.usfirst.frc3824.CompetitionRobot.Robot;
/**
 *
 */
public class SetShooterAngle extends Command
{
    private static double m_Angle, angle = 0;
    private static boolean angleSpecifiedInConstructor;
    public SetShooterAngle(double angleParam)
    {
        m_Angle = angleParam;
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.shooterAngleAdjust);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        
        // set the boolean to indicate that the constructor with angle was called
	angleSpecifiedInConstructor = true;
    }
    public SetShooterAngle()
    {
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.shooterAngleAdjust);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        
        // set the boolean to indicate that the constructor with angle was called
	angleSpecifiedInConstructor = false;
    }
    // Called just before this Command runs the first time
    protected void initialize()
    {
        // determine if the shooter angle should be pulled from the SmartDashboard
        if (angleSpecifiedInConstructor == false) {
            try {
                // Angle is currently in 0V to 3.3V
                //angle = DriverStation::GetInstance()->GetEnhancedIO().GetAnalogIn(ANALOG_SHOOTER_ADJUST);
                angle = DriverStation.getInstance().getEnhancedIO().getAnalogIn(Constants.ANALOG_SHOOTER_ADJUST_PID);
            } catch (DriverStationEnhancedIO.EnhancedIOException ex) {
                ex.printStackTrace();
            }
            // Convert the Voltage to Degrees
            angle = angle * (Constants.SHOOTER_ANGLE_MAX_VALUE - Constants.SHOOTER_ANGLE_MIN_VALUE) / 3.3 + Constants.SHOOTER_ANGLE_MIN_VALUE;
        } else {
            angle = m_Angle;
        }
        // ensure the range of the shooter angle
        if (angle > Constants.SHOOTER_ANGLE_MAX_VALUE) {
            angle = Constants.SHOOTER_ANGLE_MAX_VALUE;
        }
        if (angle < Constants.SHOOTER_ANGLE_MIN_VALUE) {
            angle = Constants.SHOOTER_ANGLE_MIN_VALUE;
        }
        // Convert the angle which is stored in degrees to ADC
        // ADC   = (angle - Y_INTERCEPT) / SLOPE
        //angle = (angle - Constants.SHOOTER_ANGLE_Y_INTERCEPT) / Constants.SHOOTER_ANGLE_SLOPE;
        
        Robot.shooterAngleAdjustPID.enable();
        Robot.shooterAngleAdjustPID.setSetpoint(angle);
    }
    // Called repeatedly when this Command is scheduled to run
    protected void execute()
    {
        if(angleSpecifiedInConstructor == false)
	{
            try {
                // Angle is currently in 0V to 3.3V
                angle = DriverStation.getInstance().getEnhancedIO().getAnalogIn(Constants.ANALOG_SHOOTER_ADJUST_PID);
            } catch (DriverStationEnhancedIO.EnhancedIOException ex) {
                ex.printStackTrace();
            }
		// Convert the Voltage to Degrees
		angle = angle * (Constants.SHOOTER_ANGLE_MAX_VALUE - Constants.SHOOTER_ANGLE_MIN_VALUE)/3.3 + Constants.SHOOTER_ANGLE_MIN_VALUE;
		
		if (angle > Constants.SHOOTER_ANGLE_MAX_VALUE)
			angle = Constants.SHOOTER_ANGLE_MAX_VALUE;
		if (angle < Constants.SHOOTER_ANGLE_MIN_VALUE)
			angle = Constants.SHOOTER_ANGLE_MIN_VALUE;
		
		// Convert the angle which is stored in degrees to ADC
		// ADC   = (angle - Y_INTERCEPT) / SLOPE
		//angle = (angle - Constants.SHOOTER_ANGLE_Y_INTERCEPT) / Constants.SHOOTER_ANGLE_SLOPE;
		   
		// Set the setpoint in ADC
		//Robot::shooterAngleAdjust->getPIDController()->SetSetpoint(angle);
                Robot.shooterAngleAdjustPID.getPIDController().setSetpoint(angle);
	}
    }
    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished()
    {
        // determine if the shooter angle is within the desired range
        //return Math.abs(angle - Robot.shooterAngleAdjustPID.getPotentiometer().pidGet()) < Constants.SHOOTER_ANGLE_THRESHOLD;
        return false;
    }
    // Called once after isFinished returns true
    protected void end()
    {
        SmartDashboard.putNumber("Shooter Angle", Robot.shooterAngleAdjustPID.getPotentiometer().pidGet());
    }
    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted()
    {
        end();
    }
}
