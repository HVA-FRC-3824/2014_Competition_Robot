// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc3824.CompetitionRobot.commands;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.DriverStationEnhancedIO;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc3824.CompetitionRobot.Constants;
import org.usfirst.frc3824.CompetitionRobot.Robot;

/**
 *
 */
public class SetShooterAngle extends Command
{
    private double m_Angle, angle;
    private boolean angleSpecifiedInConstructor;

    public SetShooterAngle(double angleParam)
    {
        m_Angle = angleParam;
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.shooterAngleAdjustPID);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        // set the boolean to indicate that the constructor with angle was called
        angleSpecifiedInConstructor = true;
    }

    public SetShooterAngle()
    {
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.shooterAngleAdjustPID);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        // set the boolean to indicate that the constructor with angle was called
        angleSpecifiedInConstructor = false;
    }

    // Called just before this Command runs the first time
    protected void initialize()
    {
        // determine if the shooter angle should be pulled from the SmartDashboard
        if (angleSpecifiedInConstructor == false)
        {
            //--- Must read the potentiometer from the SmartDashboard
            double inputVoltage = 0;
            try
            {
                // This is coming from the DRIVERS STATION/SmartDashboard, NOT from the robot
                //  The analog reading will be in the range of 0V to 3.3V
                inputVoltage = DriverStation.getInstance().getEnhancedIO().getAnalogIn(Constants.ANALOG_SHOOTER_ADJUST_PID);
            }
            catch (DriverStationEnhancedIO.EnhancedIOException ex)
            {
                ex.printStackTrace();
            }

            // Convert the Voltage to Degrees
            angle = input_ConvertVoltsToAngle(inputVoltage);
        }
        else
        {
            //--- Angle was specified in the constructor
            angle = m_Angle;
        }

        //--- We now have the angle we want in degrees
        // process it (range limit) and covert to a voltage for the PID
        // then set the PID
        Robot.shooterAngleAdjustPID.setSetpoint(output_ConvertAngleToVolts(output_limitAngle(angle)));
        Robot.shooterAngleAdjustPID.enable();
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute()
    {
        if (angleSpecifiedInConstructor == false)
        {
            double inputVoltage = 0;
            try
            {
                // Angle is currently in 0V to 3.3V
                angle = DriverStation.getInstance().getEnhancedIO().getAnalogIn(Constants.ANALOG_SHOOTER_ADJUST_PID);
            }
            catch (DriverStationEnhancedIO.EnhancedIOException ex)
            {
                ex.printStackTrace();
            }
            // Convert the Voltage from the Driver's Station input into Degrees
            angle = input_ConvertVoltsToAngle(inputVoltage);

            //--- We now have the angle we want in degrees
            // process it (range limit) and covert to a voltage for the PID
            // then set the PID
            Robot.shooterAngleAdjustPID.setSetpoint(output_ConvertAngleToVolts(output_limitAngle(angle)));
        }
        SmartDashboard.putNumber("ShooterTarget", Robot.shooterAngleAdjustPID.getSetpoint());
        SmartDashboard.putNumber("ShooterPosition", Robot.shooterAngleAdjustPID.getPosition());
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished()
    {
        // determine if the shooter angle is within the desired range
        // TODO - set threshold to accurate value!!
        return Math.abs(Robot.shooterAngleAdjustPID.getSetpoint() - Robot.shooterAngleAdjustPID.getPosition()) < 0.02;
    }

    // Called once after isFinished returns true
    protected void end()
    {
        System.out.println("SetShooterAngle - end");
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted()
    {
        System.out.println("SetShooterAngle - Interrupted");
        end();
    }

    protected double output_ConvertVoltsToAngle(double volts)
    {
        return volts;
    }

    // Convert the requested angle into a voltage in the range 0-5V
    //  The voltage is what the PID requires.
    //  The input ANGLE is the actual angle of the shooter head
    protected double output_ConvertAngleToVolts(double angle)
    {
        double volts;
        volts = ((angle - Constants.SHOOTER_ANGLE_MIN_VALUE) / (Constants.SHOOTER_ANGLE_MAX_VALUE - Constants.SHOOTER_ANGLE_MIN_VALUE)) * 5.0;
        return volts;
    }

    protected double output_limitAngle(double angle)
    {
        // ensure the range of the shooter angle
        if (angle > Constants.SHOOTER_ANGLE_MAX_VALUE)
        {
            angle = Constants.SHOOTER_ANGLE_MAX_VALUE;
        }
        if (angle < Constants.SHOOTER_ANGLE_MIN_VALUE)
        {
            angle = Constants.SHOOTER_ANGLE_MIN_VALUE;
        }

        return angle;
    }

    // Convert the voltage fromt the input into a degrees for the shooter
    protected double input_ConvertVoltsToAngle(double volts)
    {
        double angle;
        angle = volts * (Constants.SHOOTER_ANGLE_MAX_VALUE - Constants.SHOOTER_ANGLE_MIN_VALUE) / 3.3 + Constants.SHOOTER_ANGLE_MIN_VALUE;

        return angle;
    }
}
